<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on Chris Albon</title>
    <link>https://chrisalbon.com/tags/testing/</link>
    <description>Recent content in Testing on Chris Albon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Dec 2017 11:53:49 -0700</lastBuildDate>
    
	<atom:link href="https://chrisalbon.com/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mocking Functions</title>
      <link>https://chrisalbon.com/python/mocking_functions/</link>
      <pubDate>Wed, 20 Dec 2017 11:53:49 -0700</pubDate>
      
      <guid>https://chrisalbon.com/python/mocking_functions/</guid>
      <description>Preliminaries import unittest import mock from math import exp The Scenario Imagine we have a function that takes in some external API or database and we want to test that function, but with fake (or mocked) inputs. The Python mock library lets us do that.
For this tutorial pretend that math.exp is some expensive operation (e.g. database query, API call, etc) that costs \$10,000 every time we use it. To test it without paying \$10,000, we can create mock_function which imitates the behavior of math.</description>
    </item>
    
    <item>
      <title>Simple Unit Test</title>
      <link>https://chrisalbon.com/python/simple_unit_test/</link>
      <pubDate>Wed, 20 Dec 2017 11:53:49 -0700</pubDate>
      
      <guid>https://chrisalbon.com/python/simple_unit_test/</guid>
      <description>Preliminaries import unittest import sys Create Function To Be Tested def multiply(x, y): return x * y Create Test Note: It is standard practice to name a unit test test_ + &amp;lt;function being tested&amp;gt;. This naming standard allows for automated test using some libraries.
# Create a test case class TestMultiply(unittest.TestCase): # Create the unit test def test_multiply_two_integers_together(self): # Test if 4 equals the output of multiply(2,2) self.assertEqual(4, multiply(2,2)) Run Test # Run the unit test (and don&amp;#39;t shut down the Jupyter Notebook) unittest.</description>
    </item>
    
    <item>
      <title>Test Code Speed</title>
      <link>https://chrisalbon.com/python/test_code_speed/</link>
      <pubDate>Wed, 20 Dec 2017 11:53:49 -0700</pubDate>
      
      <guid>https://chrisalbon.com/python/test_code_speed/</guid>
      <description>Preliminaries import cProfile Create A Slow Function def slow_function(): total = 0.0 for i, _ in enumerate(range(10000)): for j, _ in enumerate(range(1, 10000)): total += (i * j) return total Test The Speed Of The Function cProfile.run(&amp;#39;slow_function()&amp;#39;, sort=&amp;#39;time&amp;#39;)  4 function calls in 13.291 seconds Ordered by: internal time ncalls tottime percall cumtime percall filename:lineno(function) 1 13.291 13.291 13.291 13.291 &amp;lt;ipython-input-2-64fc1cd43878&amp;gt;:1(slow_function) 1 0.000 0.000 13.291 13.291 {built-in method builtins.exec} 1 0.</description>
    </item>
    
    <item>
      <title>Test For A Specific Exception</title>
      <link>https://chrisalbon.com/python/test_for_a_specific_exception/</link>
      <pubDate>Wed, 20 Dec 2017 11:53:49 -0700</pubDate>
      
      <guid>https://chrisalbon.com/python/test_for_a_specific_exception/</guid>
      <description>Preliminaries import unittest Create A Function To Test def add(x, y): return x + y Create Test Case # Create a test case class TestAdd(unittest.TestCase): # Create the unit test def test_input_string(self): # Test To make sure a TypeError exception is raised self.assertRaises(TypeError, add(&amp;#39;Banana&amp;#39;, &amp;#39;Boat&amp;#39;)) Run Test # Run the unit test (and don&amp;#39;t shut down the Jupyter Notebook) unittest.main(argv=[&amp;#39;ignored&amp;#39;, &amp;#39;-v&amp;#39;], exit=False) test_input_string (__main__.TestAdd) ... ok ---------------------------------------------------------------------- Ran 1 test in 0.</description>
    </item>
    
    <item>
      <title>Test If Output Is Close To A Value</title>
      <link>https://chrisalbon.com/python/test_if_an_output_is_close_to_a_value/</link>
      <pubDate>Wed, 20 Dec 2017 11:53:49 -0700</pubDate>
      
      <guid>https://chrisalbon.com/python/test_if_an_output_is_close_to_a_value/</guid>
      <description>Preliminaries import unittest import sys Create Function To Be Tested def add(x, y): return x + y Create Test # Create a test case class TestAdd(unittest.TestCase): # Create the unit test def test_add_two_floats_roughly_equals_11(self): # Test if add(4.48293848, 6.5023845) return roughly (to 1 place) 11 (actual product: 10.98532298) self.assertAlmostEqual(11, add(4.48293848, 6.5023845), places=1) Run Test # Run the unit test (and don&amp;#39;t shut down the Jupyter Notebook) unittest.main(argv=[&amp;#39;ignored&amp;#39;, &amp;#39;-v&amp;#39;], exit=False) test_add_two_floats_roughly_equals_11 (__main__.</description>
    </item>
    
    <item>
      <title>Testable Documentation</title>
      <link>https://chrisalbon.com/python/testable_documentation/</link>
      <pubDate>Wed, 20 Dec 2017 11:53:49 -0700</pubDate>
      
      <guid>https://chrisalbon.com/python/testable_documentation/</guid>
      <description>Preliminaries import doctest Create A Function To Test Note that our test cases are inside the function&amp;rsquo;s documentation. Each test case is marked by a &amp;gt;&amp;gt;&amp;gt; and the expect output is the line below.
def summation(a, b): &amp;#34;&amp;#34;&amp;#34; Takes two inputs and outputs their sum. Tests: &amp;gt;&amp;gt;&amp;gt; summation(5, 4) 9 &amp;gt;&amp;gt;&amp;gt; summation(4, 3) 7 &amp;gt;&amp;gt;&amp;gt; summation(&amp;#39;foo&amp;#39;,&amp;#39;bar&amp;#39;) &amp;#39;foobar&amp;#39; &amp;gt;&amp;gt;&amp;gt; summation(3,&amp;#39;d&amp;#39;) Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: &amp;#39;int&amp;#39; and &amp;#39;str&amp;#39; &amp;#34;&amp;#34;&amp;#34; return a + b Notice that in the last test, we are making sure the function outputs the correct error.</description>
    </item>
    
  </channel>
</rss>